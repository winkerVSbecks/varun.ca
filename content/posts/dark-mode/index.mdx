---
title: Dark Mode
date: 2019-11-05
preview: ../assets/dark-mode.gif
---

import DarkModeAnimation from './dark-mode-animation';
import ColorScale from './color-scale';

<Box
  width={24 * 2.5}
  height={24 * 2.5}
  ml="auto"
  mr="auto"
  mb={6}
  overflow="hidden"
>
  <DarkModeAnimation />
</Box>

After several years of using Jekyll, I switched over my website to Gatsby. Jekyll worked great for most things. The part that I struggled with most was adding interactivity. The best I could do was embed CodePen blocks in markdown. Gatsby gives you all the benefits of static rendering and craft amazing interactive experiences with React. Josh Comeau's [Dynamic Bézier Curves post](https://www.joshwcomeau.com/posts/dynamic-bezier-curves/) or Rodrigo Pombo's [scrollycoding](https://twitter.com/pomber/status/1191784048152195075?s=20) are good examples of this.

There is much out there about [migrating to Gatsby](https://julesforrest.com/moving-to-gatsby), the benefits and the trade-offs. I want to focus on one particular challenge of my migration — dark mode. Dark themes are certainly a bit of a trend, but it also happens to be a feature many users rely on on a day-to-day basis. Most devices support it at the OS level. The user preference even cascades down to the browser and can be captured in CSS via the `prefers-color-scheme` media query.

## Colour Palette

The first step was to pick a colour palette. Inverting shades using `filter: invert(100%)` is a quick and somewhat hacky way to get to dark mode. You can follow [Daniel Eden's](https://mobile.twitter.com/_dte) advice and pair it with `hue-rotate(180deg)` for a better result. It compensates for the hue inversion. However, there is a lot more it. Inverting hues can lead to unintended consiquences such as poor contrast or shiting visual importance of UI elements. We need to be a lot more intentional about the colour palettle.

![Call-out, unintentionally, ends up with higher visual importance in dark mode](../../assets/shifting-importance.png)

Teresa Man shared extremely valuable advice in her post, [How to design delightful dark themes](https://blog.superhuman.com/how-to-design-delightful-dark-themes-7b3da644ff1f). Here are some of the key learnings that I applied to my website:

1. Avoid pure black or white. It can lead to eye fatigue and causes [black smearing](https://twitter.com/marcedwards/status/1053519077958803456).
2. Darken distant surfaces.
3. Reduce large blocks of bright colour.

My colour palette is split into two categories. Neutral scale, used for most things such as text and surface colours, and brand colours, used only used for highlights and accents.

<ColorScale />

Taking Teresa's advice, the extreme ends of the neutral scale are a blue-ish black and a light gray. The background is set to `neutral.7` and other surfaces such as code-blocks or call are set to a lighter `neutral.6`.

## Implementation

I was going for an end experience where my site supports two modes — dark and light. On the first load it defaults to the light mode. It then checks to see if the user prefers dark mode using `prefers-color-scheme: dark` media query. If yes, then switch to dark mode. There is also a button that the user can click to toggle modes. On subsequent loads the site needs to track their choice, default to it.

On the surface this seems like a failry straightforward feature set. Howver, I soon discovered that there was a lot of hidden complexity I wasn't accounting for. I'll go through those challenges in a bit but first, I want to give a major shout out to the Theme UI team. My solution is largely based on how Theme UI handles [colour mode](https://theme-ui.com/color-modes#setting-the-color-mode) switching. This blog post could easily have been titled "How Theme UI handles colour mode switching with Gatsby".

### Theme Variants

I'm using [Styled System](https://styled-system.com/) paired with [Styled-Components](https://www.styled-components.com) for the UI. Styled-Components provides theming support through its `<ThemeProvider>` component. My site has a base layout that I use for all pages, the `layout.js` file. It essentially acts at the root of the application and the themeing set up is done there. I created the dark and light variants and choose the appropriate theme based on the active mode.

### Tracking User choice

The `useColorState` hook allows us to track the active colour mode. On the first load it checks to see if the user's choice is stored in local storage or if the user has enabled dark mode at their OS level. When updating the selected mode there a couple of side-effects that need to happen:

1. Set a class on the `body` element reflecting the active mode, for example, `varun-ca-dark`
2. Save the active mode in local-storage

```js
export const useColorState = initialColorMode => {
  const [mode, setMode] = useState(initialColorMode);

  useEffect(() => {
    const stored = storage.get();
    const dark = getMediaQuery();
    if (!stored && dark) return setModeWithSideEffects('dark');
    if (!stored || stored === mode) return;
    setModeWithSideEffects(stored);
  }, []);

  const setModeWithSideEffects = () => {
    setMode(state => {
      const nextMode = state === 'light' ? 'dark' : 'light';
      document.body.classList.remove('varun-ca-' + state);
      document.body.classList.add('varun-ca-' + nextMode);
      storage.set(nextMode);
      return nextMode;
    });
  };

  return [mode, setModeWithSideEffects];
};
```

The `useColorMode` hook is essentially a think wrapper around the `useColorState` hook.

```js
export const useColorMode = () => {
  let initialMode = 'light';
  if (typeof window !== `undefined`) {
    initialMode = storage.get() ? storage.get() : 'light';
  }

  const [mode, setMode] = useColorState(initialMode);
  return [mode, setMode];
};
```

Check out [use-color-mode.js](https://github.com/winkerVSbecks/varun.ca/blob/master/src/use-color-mode.js) for more context.

1. Create the dark and light variants of the theme object
2. Create a custom hook to track the active mode `useColorMode`
3. Use the active `mode` to generate the appropriate theme object and pass that into the `ThemeProvider`

This is what my `layout.js` file looks like:

```js
const Layout = ({ title, description, image, children }) => {
  const [mode, setColorMode] = useColorMode();

  return (
    <ThemeProvider theme={{ ...theme, ...createColorStyles(mode) }}>
      <ColorModeContext.Provider value={{ mode, setColorMode }}>
        <>
          <SEO title={title} description={description} image={image} />
          <InitializeColorMode />
          <GlobalStyle />
          <MDXProvider components={dsToMdx}>{children}</MDXProvider>
        </>
      </ColorModeContext.Provider>
    </ThemeProvider>
  );
};
```

You'll notice a couple of other things here. `ColorModeContext` and `createColorStyles`.

---

- Impact — syntax highlighting, shadows, every feature.
- Theme.js, Colour naming
- First load
  — check for prefers-color-scheme: dark
  - tracking user choice
  - avoiding flash on first load with pre-render
    - Convert colours to CSS Variables
    - Change CSS Variables based on theme
