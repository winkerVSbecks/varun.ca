---
title: Breakdown Of Storybook Day 3D Scene
date: 2022-12-20
image: ../../assets/solarstorm-particles.png
---

import { MVP } from './lazy-scenes';
import spherePacking from '../../assets/sphere-packing.mp4';
import zOffset from '../../assets/z-offset.mp4';
import focusDistance from '../../assets/focus-distance.mp4';
import extrude from '../../assets/extrude.mp4';

Storybook's version 7.0 is a major milestone, featuring a re-engineered codebase, improved performance, and hundreds of new features. To celebrate, the Storybook team is hosting their first ever user conference‚Äî[Storybook Day](https://storybook.js.org/day). To make the occasion even more special, the team wanted to add a visually stunning 3D element to the event landing page.

Using React Three Fiber, we created a 3D illustration that serves as the page's centrepiece. This article explores the finer details of shipping a 3D scene using React Three Fiber. We'll cover a range of topics, including:

- üèóÔ∏è Randomly placing objects without any overlap using sphere packing
- üß± Modelling tetris blocks using extrusion
- üé• Adding post-processing effects such as depth of field and shadows
- üèéÔ∏è Performance optimizations to ensure smooth rendering on all devices

<CallOut>
  ‚ÑπÔ∏è This post assumes foundational knowledge of React Three Fiber. If you're
  new to 3D or not familiar with the R3F API, check out my{' '}
  <a href="/modular-webgl/">intro post</a> for a primer.
</CallOut>

## Our strategy

The scene consists of extruded text with blocks floating around it. To build the event site, we used NextJS, so it made sense to also use [@react-three/fiber](https://github.com/pmndrs/react-three-fiber). Additionally, [@react-three/drei](https://github.com/pmndrs/drei) provided helpful utilities such as Text3D and Float.

Here's an MVP in code, which will act as our starting point:

<MVP />

<!-- ![layers of the scene: extruded text, floating shapes, contact shadows and depth of field](../../assets/scene-parts.gif) -->

## The Details

On to the fun stuff. Notice how the blocks are randomly spread across the scene and sometimes overlap with the text or each other. It would be aesthetically more pleasing if the blocks had no overlap. That‚Äôs one example of little adjustments we made to take this scene from MVP to production ready. Let‚Äôs explore these techniques in detail.

### Sphere packing to place blocks

The [pack-sphere](https://github.com/mattdesl/pack-spheres) library enabled us to evenly distribute the blocks and prevent any potential overlapping issues. This library employs a brute force approach to arrange spheres of varying radii within a cube.

```js
const spheres = pack({
  maxCount: 40,
  minRadius: 0.125,
  maxRadius: 0.25,
});
```

Then scale the spheres to our scene space and stretch them horizontally along the x-axis. We then placed a block at the centre of each sphere, scaled to the radius of the sphere.

<SourceCard
  name="Sphere packing to spread out blocks"
  link="https://github.com/storybookjs/storybook-day/blob/main/components/BlocksScene/BlocksScene.tsx#L22"
>
  <Box bg="#323132">
    <Video autoplay loop muted playsInline display="block" mb="0">
      <source src={spherePacking} type="video/mp4" />
    </Video>
  </Box>
</SourceCard>

Fixing the overlap between the "7.0" text and the blocks required a different approach. We considered using [pack-sphere](https://github.com/mattdesl/pack-spheres) to check for collisions between the spheres and the text geometry. In the end, we chose a simpler solution: shifting the spheres slightly along the z-axis.

<SourceCard
  name="Z axis offset to prevent overlapping with text"
  link="https://github.com/storybookjs/storybook-day/blob/main/components/BlocksScene/BlocksScene.tsx#L36"
>
  <Box bg="#323132">
    <Video autoplay loop muted playsInline display="block" mb="0">
      <source src={zOffset} type="video/mp4" />
    </Video>
  </Box>
</SourceCard>

Here's the entire process, in code:

```js
// Sphere packing
const spheres = pack({
  maxCount: 40,
  minRadius: 0.125,
  maxRadius: 0.25,
}).map((sphere) => {
  const inFront = sphere.position[2] >= 0;
  return {
    ...sphere,
    position: [
      sphere.position[0],
      sphere.position[1],
      // offset to avoid overlapping with the 7.0 text
      inFront ? sphere.position[2] + 0.6 : sphere.position[2] - 0.6,
    ],
  };
});

const size = 5.5;
// stretch horizontally
const scale = [size * 6, size, size];

const blocks = spheres.map((sphere, index) => ({
  ...sphere,
  id: index,
  // scale position to scene space
  position: sphere.position.map((v, idx) => v * scale[idx]),
  // scale radius to scene space
  size: sphere.radius * size * 1.5,
  color: Random.pick(colors),
  type: Random.pick(blockTypes),
  rotation: new THREE.Quaternion(...Random.quaternion()),
}));
```

## Extrusion to model tetris blocks

You may have noticed that we have only used primitive blocks so far. Hey, no hating on primitives, but Storybook branding uses tetris-style blocks, so we need to add those into the mix.

Three.js has the concept of [ExtrudeGeometry](https://threejs.org/docs/#api/en/geometries/ExtrudeGeometry). You can provide it with a 2D shape, using a syntax similar to SVG path or CSS shapes. It then extrudes it along the z-axis, which is perfect for tetris blocks.

<SourceCard
  name="Extrude a tetris block"
  link="https://github.com/storybookjs/storybook-day/blob/main/components/BlocksScene/TetrisBlock.tsx"
>
  <Box bg="#323132">
    <Video autoplay loop muted playsInline display="block" mb="0">
      <source src={extrude} type="video/mp4" />
    </Video>
  </Box>
</SourceCard>

The Extrude utility from Drei provides a convenient syntax for creating such shapes. For example, the "T" block was generated as follows:

```jsx
import { useMemo } from 'react';
import * as THREE from 'three';
import { Extrude } from '@react-three/drei';

export const EXTRUDE_SETTINGS = {
  steps: 2,
  depth: 0.5625,
  bevelEnabled: false,
};

export const TBlock = ({ type, color, ...props }) => {
  const shape = useMemo(() => {
    const _shape = new THREE.Shape();
    _shape.moveTo(0, 0);
    _shape.lineTo(SIDE, 0);
    _shape.lineTo(SIDE, SIDE * 3);
    _shape.lineTo(0, SIDE * 3);
    _shape.lineTo(0, SIDE * 2);
    _shape.lineTo(-SIDE, SIDE * 2);
    _shape.lineTo(-SIDE, SIDE);
    _shape.lineTo(0, SIDE);
    return _shape;
  }, []);

  return (
    <Extrude args={[shape, EXTRUDE_SETTINGS]} {...props}>
      <meshPhongMaterial color={color} />
    </Extrude>
  );
};
```

Next, we layered on shadows and depth of field effect to add some oomph.

## Add shadows

Shadows add a sense of depth and realism to the scene. You can configure lights and meshes within the scene to cast shadows using the [`castShadow`](https://threejs.org/docs/#api/en/lights/DirectionalLight.castShadow) prop. However, we still need a mechanism to render the shadows. Yet again, we reached for Drei.

I cannot overstate how useful the Drei library is. It has utilities for all kinds of common effects, including contact shadows. In fact, the `ContactShadows` component makes this task trivial.

The component calculates shadows and renders them to a texture. It also adds a plane to the scene to which the shadow texture is applied. You can then customize the look of the shadow by adjusting the resolution, opacity, blur, color, and other properties.

TODO: turn into a sandbox

```jsx
import { Canvas } from '@react-three/fiber';
import { ContactShadows } from '@react-three/drei';

export const Scene = () => (
  <Canvas>
    <ContactShadows resolution={512} opacity={0.5} />
    {/* Our 3D objects go here */}
  </Canvas>
);
```

## Add depth of field effect

At this stage, every object in the scene is rendered with the same sharpness, making the scene appear somewhat flat. Photographers, often use wide apertures and shallow depth of field to create a pleasing blurred aesthetic. We mimicked this effect by applying post-processing effects‚Äîusing `[@react-three/postprocessing](https://docs.pmnd.rs/react-postprocessing/introduction)`‚Äîto our scene, giving it a more cinematic feel.

**Post-processing pipeline**

The [EffectComposer](https://pmndrs.github.io/postprocessing/public/docs/class/src/core/EffectComposer.js~EffectComposer.html) manages and runs post-processing passes. It begins by rendering the scene to a buffer and then applies filters and effects one at a time before rendering the final image onto the screen.

```jsx
import { Canvas } from '@react-three/fiber';
import { EffectComposer, DepthOfField } from '@react-three/postprocessing';

export const Scene = () => (
  <Canvas>
    {/* Rest of Our scene */}
    <EffectComposer multisampling={8}>
      <DepthOfField focusDistance={0.5} bokehScale={7} focalLength={0.2} />
    </EffectComposer>
  </Canvas>
);
```

<SourceCard
  name="Where to focus within the scene"
  link="https://github.com/storybookjs/storybook-day/blob/main/components/BlocksScene/BlocksScene.tsx#L97"
>
  <Box bg="#323132">
    <Video autoplay loop muted playsInline display="block" mb="0">
      <source src={focusDistance} type="video/mp4" />
    </Video>
  </Box>
</SourceCard>

A depth of field effect can add a sense of realism and depth to a 3D scene by blurring objects that are out of focus.

To add a depth of field effect to our scene, we can use the DepthOfField component from the @react-three/postprocessing library. First, let's install the library by running the following command in our terminal:

```
npm install @react-three/postprocessing
```

Next, let's import the DepthOfField component and add it to our scene. The DepthOfField component takes care of setting up the necessary postprocessing passes and rendering them to a texture. It also provides several props that allow us to customize the depth of field effect, such as focusDistance and aperture.

```
import { DepthOfField } from '@react-three/postprocessing'

<Canvas>
  <DepthOfField focusDistance={2} aperture={0.05} />
  {/* Our 3D objects go here */}
</Canvas>
```

Now, when we render our scene, objects that are closer to the focus distance will be in focus, while objects that are farther away will be blurred.

You can further customize the depth of field effect by adjusting the focusDistance and aperture props. The focusDistance prop determines the distance from the camera at which objects are in focus, and the aperture prop determines the size of the lens aperture, which controls the amount of blur.

You can also use the focalLength prop to adjust the focal length of the camera, which determines the magnification of the image and the distance at which objects are in focus.

```
<DepthOfField focusDistance={2} aperture={0.05} focalLength={50} />
```

That's it! With just a few lines of code, we've added a depth of field effect to our 3D scene.

I hope this tutorial has helped you get started with creating a 3D illustration with React Three Fiber and adding a depth of field effect with the `@react-three/postprocessing` library. If you have any questions or feedback, feel free to leave a comment below. Happy coding!

## Performance optimization: use a material store

Shadows and depth of field effects can add a sense of realism and depth to a 3D scene, but they can also have a significant impact on performance. In this section, we'll look at how we can optimize the performance of our scene by using a material store.

A material store is a React context that stores a reference to a material instance. This allows us to reuse the same material instance across multiple components, which can improve performance by reducing the number of materials that need to be created and rendered.

## Wrap up

3D is increasingly becoming a part of the web, and React Three Fiber is a great tool for creating 3D scenes with React. It's not uncommon to see polished 3D illustrations on the web but most tutorials focus on the basics. With this post, I wanted to pull the curtain back and focus on the final 20%. The little tweaks and happy accidents that can make a big difference.

If you have any questions or feedback, feel free to reach out via [twitter](https://twitter.com/winkerVSbecks). Happy coding!
