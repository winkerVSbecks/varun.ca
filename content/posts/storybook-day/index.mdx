---
title: Breakdown Of Storybook Day 3D Scene
date: 2023-04-01
image: ../../assets/solarstorm-particles.png
---

import { MVP, Shadows } from './lazy-scenes';
import spherePacking from '../../assets/sphere-packing.mp4';
import zOffset from '../../assets/z-offset.mp4';
import focusDistance from '../../assets/focus-distance.mp4';
import extrude from '../../assets/extrude.mp4';

Storybook just hit a major milestone: version 7.0! With a re-engineered codebase and bunch of new features, it's faster and more stable than ever before. To celebrate, the team hosted their first ever user conference‚Äî[Storybook Day](https://storybook.js.org/day). And to make things even more special, we decided to add a visually stunning 3D element to the event landing page.

We used React Three Fiber to build an eye-catching 3D illustration, inspired by Storybook's Tetris blocks branding. In this article, we'll dive into the nitty-gritty of shipping a 3D scene. Here's what we'll cover:

- üèóÔ∏è Avoid object overlap with sphere packing
- üß± Model Tetris blocks with extrusion
- üé• Enhance visuals with post-processing effects like depth of field and shadows
- üèéÔ∏è Optimize performance for glitch-free rendering on all devices

<CallOut>
  ‚ÑπÔ∏è This post assumes foundational knowledge of React Three Fiber. If you're
  new to 3D or not familiar with the R3F API, check out my{' '}
  <a href="/modular-webgl/">intro post</a> for a primer.
</CallOut>

## Our strategy

To build the event site, we used NextJS and [@react-three/fiber](https://github.com/pmndrs/react-three-fiber), with a little help from [@react-three/drei](https://github.com/pmndrs/drei). This allowed us to create an eye-catching 3D scene, complete with floating Tetris blocks and extruded text.

Here's an MVP in code, that was our starting point:

<MVP />

## The Details

On to the fun stuff. Notice how the blocks are randomly spread across the scene and sometimes overlap with the text or each other. It would be aesthetically more pleasing if the blocks had no overlap. That's one example of little adjustments we made to take this scene from MVP to production ready. Let's explore these techniques in detail.

### Sphere packing to place blocks

The [pack-sphere](https://github.com/mattdesl/pack-spheres) library enabled us to evenly distribute the blocks and prevent any potential overlapping issues. This library employs a brute force approach to arrange spheres of varying radii within a cube.

```js
const spheres = pack({
  maxCount: 40,
  minRadius: 0.125,
  maxRadius: 0.25,
});
```

We then scaled the spheres to fit our scene space and stretched them horizontally along the x-axis. Lastly, we placed a block at the center of each sphere, scaled to the sphere's radius.

<SourceCard
  name="Sphere packing to spread out blocks"
  link="https://github.com/storybookjs/storybook-day/blob/main/components/BlocksScene/BlocksScene.tsx#L22"
>
  <Box bg="#323132">
    <Video autoplay loop muted playsInline display="block" mb="0">
      <source src={spherePacking} type="video/mp4" />
    </Video>
  </Box>
</SourceCard>

Fixing the overlap between the "7.0" text and the blocks required a different approach. We considered using [pack-sphere](https://github.com/mattdesl/pack-spheres) to check for collisions between the spheres and the text geometry. In the end, we chose a simpler solution: shifting the spheres slightly along the z-axis.

<SourceCard
  name="Z axis offset to prevent overlapping with text"
  link="https://github.com/storybookjs/storybook-day/blob/main/components/BlocksScene/BlocksScene.tsx#L36"
>
  <Box bg="#323132">
    <Video autoplay loop muted playsInline display="block" mb="0">
      <source src={zOffset} type="video/mp4" />
    </Video>
  </Box>
</SourceCard>

Here's the entire process, in code:

```js
// Sphere packing
const spheres = pack({
  maxCount: 40,
  minRadius: 0.125,
  maxRadius: 0.25,
}).map((sphere) => {
  const inFront = sphere.position[2] >= 0;
  return {
    ...sphere,
    position: [
      sphere.position[0],
      sphere.position[1],
      // offset to avoid overlapping with the 7.0 text
      inFront ? sphere.position[2] + 0.6 : sphere.position[2] - 0.6,
    ],
  };
});

const size = 5.5;
// stretch horizontally
const scale = [size * 6, size, size];

const blocks = spheres.map((sphere, index) => ({
  ...sphere,
  id: index,
  // scale position to scene space
  position: sphere.position.map((v, idx) => v * scale[idx]),
  // scale radius to scene space
  size: sphere.radius * size * 1.5,
  color: Random.pick(colors),
  type: Random.pick(blockTypes),
  rotation: new THREE.Quaternion(...Random.quaternion()),
}));
```

## Extrusion to model tetris blocks

You may have noticed that we've only used primitive blocks so far. Hey, no hating on primitives, but Storybook branding uses tetris-style blocks, so we had to add those into the mix.

Three.js has the concept of [ExtrudeGeometry](https://threejs.org/docs/#api/en/geometries/ExtrudeGeometry). You can provide it with a 2D shape, using a syntax similar to SVG path or CSS shapes. It then extrudes it along the z-axis, which is perfect for tetris blocks.

<SourceCard
  name="Extrude a tetris block"
  link="https://github.com/storybookjs/storybook-day/blob/main/components/BlocksScene/TetrisBlock.tsx"
>
  <Box bg="#323132">
    <Video autoplay loop muted playsInline display="block" mb="0">
      <source src={extrude} type="video/mp4" />
    </Video>
  </Box>
</SourceCard>

The Extrude utility from Drei provides a convenient syntax for creating such shapes. For example, the "T" block was generated as follows:

```jsx
import { useMemo } from 'react';
import * as THREE from 'three';
import { Extrude } from '@react-three/drei';

export const EXTRUDE_SETTINGS = {
  steps: 2,
  depth: 0.5625,
  bevelEnabled: false,
};

export const TBlock = ({ type, color, ...props }) => {
  const shape = useMemo(() => {
    const _shape = new THREE.Shape();
    _shape.moveTo(0, 0);
    _shape.lineTo(SIDE, 0);
    _shape.lineTo(SIDE, SIDE * 3);
    _shape.lineTo(0, SIDE * 3);
    _shape.lineTo(0, SIDE * 2);
    _shape.lineTo(-SIDE, SIDE * 2);
    _shape.lineTo(-SIDE, SIDE);
    _shape.lineTo(0, SIDE);
    return _shape;
  }, []);

  return (
    <Extrude args={[shape, EXTRUDE_SETTINGS]} {...props}>
      <meshPhongMaterial color={color} />
    </Extrude>
  );
};
```

Next, we layered on shadows and depth of field effect to add some oomph.

## Add shadows

Shadows bring scenes to life by adding depth and realism. You can configure lights and meshes within the scene to cast shadows using the [`castShadow`](https://threejs.org/docs/#api/en/lights/DirectionalLight.castShadow) prop. However, we were looking for a softer look, so once again we reached for Drei, which offers a convenient contact shadows component.

Contact shadows is a "fake shadow" effect. It films the scene from below and renders the shadow into a catcher plane. The shadow is accumulated over several frames and is often softer and more realistic.

To use it, add the `ContactShadows` component to the scene. Then customize the look by adjusting the resolution, opacity, blur, color, and other properties.

<Shadows />

## Add depth of field effect

At this stage, every object in the scene is rendered with the same sharpness, making the scene appear somewhat flat. Photographers, often use wide apertures and shallow depth of field to create a pleasing blurred aesthetic. We mimicked this effect by applying post-processing effects‚Äîusing [@react-three/postprocessing](https://docs.pmnd.rs/react-postprocessing/introduction)‚Äîto our scene, giving it a more cinematic feel.

**Post-processing pipeline: Scene render -> pixel data -> effects composer -> pass 1: DoF -> pixel data -> pass 2: bloom -> pixel data -> etc. -> render to screen**

The [EffectComposer](https://pmndrs.github.io/postprocessing/public/docs/class/src/core/EffectComposer.js~EffectComposer.html) manages and runs post-processing passes. It begins by rendering the scene to a buffer and then applies filters and effects one at a time before rendering the final image onto the screen.

With the DepthOfField effect, you can pinpoint a specific distance (`focusDistance`) within your scene and make everything else beautifully blurry. But how do you define the focus distance? Is it measured in world units or something else?

```jsx
import { Canvas } from '@react-three/fiber';
import { EffectComposer, DepthOfField } from '@react-three/postprocessing';

export const Scene = () => (
  <Canvas>
    {/* Rest of Our scene */}
    <EffectComposer multisampling={8}>
      <DepthOfField focusDistance={0.5} bokehScale={7} focalLength={0.2} />
    </EffectComposer>
  </Canvas>
);
```

The camera's view is defined by a pyramid-shaped volume called the "view frustum." Objects within the minimum (near plane) and maximum (far plane) distances from the camera will be rendered.

<figure px="4">
  <img
    alt="View Frustum this is a pyramid which has 2 clipping planes. Objects or parts of objects found outside the frustum, won't be rendered"
    src="../../assets/viewport-3d-scene.png"
  />
  <figcaption>
    <a href="https://obviam.net/posts/2011/06.3d-perspective-projections/">
      From: Intro to 3D Programming - Perspective Projections
    </a>
  </figcaption>
</figure>

The `focusDistance` parameter determines the distance from the camera at which objects are considered in focus. Its value is normalized between 0 and 1, where 0 represents the near plane of the camera and 1 represents the far plane.

<SourceCard
  name="Where to focus within the scene"
  link="https://github.com/storybookjs/storybook-day/blob/main/components/BlocksScene/BlocksScene.tsx#L97"
>
  <Box bg="#323132">
    <Video autoplay loop muted playsInline display="block" mb="0">
      <source src={focusDistance} type="video/mp4" />
    </Video>
  </Box>
</SourceCard>

Now, when we render our scene, objects that are closer to the focus distance will be in focus, while objects that are farther away will be blurred.

You can further customize the depth of field effect by adjusting the focusDistance and aperture props. The focusDistance prop determines the distance from the camera at which objects are in focus, and the aperture prop determines the size of the lens aperture, which controls the amount of blur.

You can also use the focalLength prop to adjust the focal length of the camera, which determines the magnification of the image and the distance at which objects are in focus.

```
<DepthOfField focusDistance={2} aperture={0.05} focalLength={50} />
```

That's it! With just a few lines of code, we've added a depth of field effect to our 3D scene.

I hope this tutorial has helped you get started with creating a 3D illustration with React Three Fiber and adding a depth of field effect with the `@react-three/postprocessing` library. If you have any questions or feedback, feel free to leave a comment below. Happy coding!

## Performance optimization: use a material store

Shadows and depth of field effects can add a sense of realism and depth to a 3D scene, but they can also have a significant impact on performance. In this section, we'll look at how we can optimize the performance of our scene by using a material store.

A material store is a React context that stores a reference to a material instance. This allows us to reuse the same material instance across multiple components, which can improve performance by reducing the number of materials that need to be created and rendered.

## Wrap up

3D is increasingly becoming a part of the web, and React Three Fiber is a great tool for creating 3D scenes with React. It's not uncommon to see polished 3D illustrations on the web but most tutorials focus on the basics. With this post, I wanted to pull the curtain back and focus on the final 20%. The little tweaks and happy accidents that can make a big difference.

I cannot overstate how useful the Drei library is. It has utilities for all kinds of common effects, including contact shadows.

If you have any questions or feedback, feel free to reach out via [twitter](https://twitter.com/winkerVSbecks). Happy coding!
